// inviteMonitor.js
const qrcode = require('qrcode-terminal');
const { Client, LocalAuth } = require('whatsapp-web.js');
const { addToWhitelist, removeFromWhitelist, listWhitelist } = require('./services/whitelistService');
const { addToBlacklist, removeFromBlacklist, listBlacklist, isBlacklisted } = require('./services/blacklistService');
const { addMutedUser, removeMutedUser, loadMutedUsers } = require('./services/muteService');
const { jidKey } = require('./utils/jidUtils');

// Add timestamp helper function
function getTimestamp() {
  return new Date().toLocaleString('en-GB', { timeZone: 'Asia/Jerusalem' });
}

console.log(`[${getTimestamp()}] ğŸš€ Bot starting... initializing WhatsApp Web`);

const { translate } = require('@vitalets/google-translate-api');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Firestore & Command Cache Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Firestore configuration
const db = require('./firebaseConfig');

//for mute logic
let mutedUsers = new Map();
const mutedMsgCounts  = new Map();


// Firestore reference and in-memory cache
let cachedCommands = {};
const startTime = Date.now();
// load all commands from Firestore into cache
async function loadCommands() {
  try {
    const snapshot = await db.collection('commands').get();
    cachedCommands = {};
    snapshot.forEach(doc => {
      const cmd = doc.data().cmd.trim().toLowerCase();
      cachedCommands[cmd] = doc.data();
    });
    console.log(`[${getTimestamp()}] ğŸ“¥ Commands loaded:`, Object.keys(cachedCommands));
  } catch (e) {
    console.error(`[${getTimestamp()}] âŒ failed to load commands:`, e);
  }
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€



/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ BOT CLIENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const client = new Client({
  authStrategy: new LocalAuth(),
  puppeteer: {
    headless: true,
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-dev-shm-usage',
      '--disable-gpu',
      '--disable-software-rasterizer'
    ]
  }
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ONE-TIME LOGIN HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
client.on('qr', qr => {
  console.log(`[${getTimestamp()}] [DEBUG] QR code received, generatingâ€¦`);
  qrcode.generate(qr, { small: true });
  console.log(`[${getTimestamp()}] ğŸ“±  Scan the QR code above to log in.`);
});

client.on('authenticated', () => console.log(`[${getTimestamp()}] âœ…  Authenticated!`));
client.on('ready', async () => {
  console.log(`[${getTimestamp()}] âœ…  Bot is ready and logged in!`);
  console.log(`
   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ–ˆâ•—â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ•—â–‘â–‘â–‘â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
  â–ˆâ–ˆâ•”â•â•â•â•â•â–‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ•”â•â•â•â•â•
  â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–‘
  â–ˆâ–ˆâ•‘â–‘â–‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ•”â•â•â•â–‘â–‘
  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–‘â•šâ•â•â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
  â–‘â•šâ•â•â•â•â•â•â–‘â–‘â•šâ•â•â•â•â•â–‘â•šâ•â•â–‘â–‘â–‘â–‘â–‘â•šâ•â•â•šâ•â•â–‘â–‘â•šâ•â•â–‘â•šâ•â•â•â•â•â•â–‘â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•
    ğŸ¤– CommunityGuard is now watching for group invite linksâ€¦
  `);
    // first load commands from Firestore
    await loadCommands();
    
   mutedUsers = await loadMutedUsers();
   console.log(`[${getTimestamp()}] âœ… Mute list loaded`);

   console.log(`[${getTimestamp()}] Version 1.0.9 - LID Support Update`);
   console.log(`[${getTimestamp()}] âœ…  Bot is ready, commands cache populated!`);
});
client.on('auth_failure', e => console.error(`[${getTimestamp()}] âŒ  AUTH FAILED`, e));

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONFIGURATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const ADMIN_PHONE = '972555020829';
const ADMIN_LID = '972555020829';
const ALERT_PHONE = '972544345287';
// Store whitelist as JIDs so it also matches new @lid accounts
const WHITELIST   = new Set([ jidKey(ADMIN_PHONE), jidKey(ALERT_PHONE) ]);

// Helper to produce a userâ€readable label (number if available, otherwise JID)
function describeContact(contact) {
  if (!contact) return '[unknown]';
  // Prefer the full JID (works for both legacy and LID accounts)
  const jid = contact.id?._serialized || contact._serialized;
  // Fallback to legacy phoneâ€based number if still present
  return jid || contact.number || '[unknown]';
}

// Enhanced helper to get participant JID with LID support
function getParticipantJid(participant) {
  // For LID users, the JID might be in different formats
  if (participant.id?._serialized) {
    return participant.id._serialized;
  }
  if (participant._serialized) {
    return participant._serialized;
  }
  if (participant.id?.user) {
    // Handle LID format (e.g., "123456@lid")
    const server = participant.id.server || 'c.us';
    return `${participant.id.user}@${server}`;
  }
  return null;
}

// Enhanced helper to get message author with LID support
function getMessageAuthor(msg) {
  // Try multiple ways to get the author
  // For group messages, author contains the sender's JID
  if (msg.author) return msg.author;
  
  // For direct messages or when author is not set
  if (msg.from) {
    // If it's a group message, extract participant
    if (msg.from.includes('@g.us') && msg.id?.participant) {
      return msg.id.participant;
    }
    return msg.from;
  }
  
  // Fallback to participant if available
  if (msg.id?.participant) return msg.id.participant;
  
  // Last resort - check if message has _data with author
  if (msg._data?.author) return msg._data.author;
  
  return null;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UNIFIED message_create HANDLER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

function cleanPhoneNumber(phone) {
  // Remove any Unicode invisible characters (LRM, RLM, etc.)
  const normalized = phone.replace(/[\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, '');
  // Remove plus, spaces, dashes, and any other formatting characters
  return normalized.replace(/[+\s-]/g, '');
}

client.on('message_create', async msg => {
  // strip bidi chars & normalise
  const cleaned  = msg.body.replace(/\u200e/g, '').trim();
  const lowered  = cleaned.toLowerCase();
  // split into all parts, shift off the command, then re-join the rest:
  const parts = lowered.split(/\s+/);
  const cmd   = parts.shift();
  const arg   = parts.join(' ');

    if (cmd === '#mute' && !msg.hasQuotedMsg) {
    // Check if the message is from an admin
    console.log(`[${getTimestamp()}] ğŸ”Š Mute command received`);
    const chat = await msg.getChat();
    const sender = await msg.getContact();

    if (!chat.isGroup) {
      await msg.reply('âš ï¸ This command can only be used in groups.');
      return;
    }

    const senderJid = getParticipantJid(sender);
    const isAdmin = chat.participants.some(p => {
      const pJid = getParticipantJid(p);
      return pJid === senderJid && p.isAdmin;
    });
    
    if (!isAdmin) {
      await msg.reply('ğŸš« You must be an admin to mute the group.');
      return;
    }

    // Validate the mute duration
 
    if (!arg || isNaN(parseInt(arg, 10)) || parseInt(arg, 10) <= 0) {
      await msg.reply('âš ï¸ Please specify a valid number of minutes. Example: #mute 10');
      return;
    }

    // Mute the group (admin-only messages)
    try {
      await chat.sendMessage(`ğŸ”‡ ×”×§×‘×•×¦×” ×”×•×©×ª×§×” ×œ××©×š ${arg} ×“×§×•×ª.`);

      await chat.setMessagesAdminsOnly(true);

      console.log(`[${getTimestamp()}] âœ… Group muted for ${arg} minutes by ${sender.pushname}`);

      // Set a timeout to unmute after the specified duration
      setTimeout(async () => {
        await chat.setMessagesAdminsOnly(false);
        //await chat.sendMessage('ğŸ”Š Group has been unmuted.');
        console.log(`[${getTimestamp()}] âœ… Group unmuted automatically after timeout.`);
      }, parseInt(arg, 10) * 60000); // Convert minutes to milliseconds
    } catch (err) {
      await msg.reply('âŒ Failed to mute the group.');
      console.error(`[${getTimestamp()}] Mute error:`, err.message);
    }
    return;
  }

  // â”€â”€â”€â”€â”€â”€â”€ Mute Specific User via Reply (#mute [minutes]) â”€â”€â”€â”€â”€â”€â”€

// Mute Specific User via Reply (#mute [minutes])
if (msg.hasQuotedMsg && cmd === '#mute') {
    try {
        const chat = await msg.getChat();
        const sender = await msg.getContact();
        let quotedMsg;
              try {
                  quotedMsg = await msg.getQuotedMessage();
                  if (!quotedMsg) throw new Error('Quoted message not found');
              } catch (err) {
                  console.error('âŒ Could not retrieve quoted message:', err.message);
                  await msg.reply('âš ï¸ Unable to retrieve the quoted message. Please try again.');
                  return;
              }

        // Check if the message is from a group and the sender is an admin
        if (!chat.isGroup) {
            await msg.reply('âš ï¸ This command can only be used in groups.');
            return;
        }

        const senderJid = getParticipantJid(sender);
        const isAdmin = chat.participants.some(p => {
            const pJid = getParticipantJid(p);
            return pJid === senderJid && p.isAdmin;
        });

        if (!isAdmin) {
            await msg.reply('ğŸš« You must be an admin to mute a user.');
            return;
        }

        // Validate mute duration (minutes or days)
        let muteDurationMs;
        if (!isNaN(arg)) {
            // Only minutes provided
            muteDurationMs = parseInt(arg, 10) * 60000;
        } else {
            const [mm, dd] = arg.split(' ');
            const minutes = parseInt(mm, 10);
            const days = parseInt(dd, 10) || 0;
            muteDurationMs = (minutes * 60000) + (days * 86400000); // Convert to ms
        }

        if (isNaN(muteDurationMs) || muteDurationMs <= 0) {
            await msg.reply('âš ï¸ Please specify a valid number of minutes or days. Example: #mute 10 or #mute 10 2');
            return;
        }

        // Get the target user from the replied-to message
        const target = getMessageAuthor(quotedMsg);
        if (!target) {
            await msg.reply('âš ï¸ Unable to identify the user to mute.');
            return;
        }

        // Ensure the bot is an admin - find bot by checking isMe property
        let botParticipant = null;
        let botJid = null;
        
        // Method 1: Find participant with isMe property
        for (const p of chat.participants) {
            try {
                const contact = await client.getContactById(getParticipantJid(p));
                if (contact.isMe) {
                    botParticipant = p;
                    botJid = getParticipantJid(p);
                    console.log(`[${getTimestamp()}] Found bot via isMe: ${botJid}`);
                    break;
                }
            } catch (e) {
                // Continue checking other participants
            }
        }
        
        // Method 2: If not found, try using client.info
        if (!botParticipant && client.info && client.info.wid) {
            const testJid = client.info.wid._serialized || client.info.wid;
            botParticipant = chat.participants.find(p => {
                const pJid = getParticipantJid(p);
                return pJid === testJid || pJid === jidKey(testJid);
            });
            if (botParticipant) {
                botJid = getParticipantJid(botParticipant);
                console.log(`[${getTimestamp()}] Found bot via client.info: ${botJid}`);
            }
        }
        
        if (!botParticipant || !botParticipant.isAdmin) {
            console.log(`[${getTimestamp()}] Bot admin check failed.`);
            console.log(`[${getTimestamp()}] Bot found: ${botParticipant ? 'Yes' : 'No'}`);
            console.log(`[${getTimestamp()}] Bot JID: ${botJid || 'Not found'}`);
            console.log(`[${getTimestamp()}] Bot is admin: ${botParticipant ? botParticipant.isAdmin : 'N/A'}`);
            await msg.reply('âš ï¸ The bot must be an admin to mute users.');
            return;
        }

        // Calculate mute expiration time
        const muteUntil = Date.now() + muteDurationMs;

        // Save to in-memory map and Firestore
        mutedUsers.set(target, muteUntil);
        await addMutedUser(target, muteUntil);

        // Send confirmation message
        try {
          await client.sendMessage(
            msg.from,
            `ğŸ”‡ @${target.split('@')[0]} ğŸ”’ â›” â³`
          );
        } catch (e) {
          console.error('âš ï¸ Failed to send mute confirmation:', e.message);
        }

        console.log(`âœ… User @${target.split('@')[0]} muted for ${arg}`);

        const parts = arg.split(' ');
        let durationText;
        if (parts.length === 1) {
          const mins = parseInt(parts[0], 10);
          durationText = `${mins} minute${mins !== 1 ? 's' : ''}`;
        } else {
          const mins = parseInt(parts[0], 10);
          const days = parseInt(parts[1], 10);
          durationText = `${days} day${days !== 1 ? 's' : ''} and ${mins} minute${mins !== 1 ? 's' : ''}`;
        }

        const warningMessage = [
          `â— ×”×™× ×š ×—×¡×•× ×œ×©×œ×™×—×ª ×”×•×“×¢×•×ª ×œ××©×š ${durationText}. ×”××©×š ×©×œ×™×—×ª ×”×•×“×¢×•×ª ×‘××”×œ×š ×ª×§×•×¤×ª ×”×”×’×‘×œ×” ×¢×©×•×™ ×œ×”×•×‘×™×œ ×œ×—×¡×™××”.`,
          `ğŸ•°ï¸ ×ª×§×‘×œ ×”×•×“×¢×” ×›××©×¨ ×”××’×‘×œ×” ×ª×•×¡×¨.`,
          `------------------------------`,
          `ğŸ”‡ You have been restricted from sending messages for ${durationText}.`,
          `ğŸš« Continuing to send messages during the restriction period may result in a ban.`,
          `ğŸ•°ï¸ You will receive a notification once the restriction is lifted.`,
          `------------------------------`,

          `â— Ğ’Ñ‹ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ñ‹ Ğ² Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ½Ğ° ${durationText}. ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ²Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¸Ğ²ĞµÑÑ‚Ğ¸ Ğº Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞµ.`,
          `ğŸ•°ï¸ Ğ’Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ, ĞºĞ¾Ğ³Ğ´Ğ° Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Ğ±ÑƒĞ´ĞµÑ‚ ÑĞ½ÑÑ‚Ğ¾.`,
          `------------------------------`,
          `â— Vous Ãªtes restreint d'envoyer des messages pendant ${durationText}. Continuer Ã  envoyer des messages pendant la pÃ©riode de restriction peut entraÃ®ner une interdiction.`,
          `ğŸ•°ï¸ Vous recevrez une notification une fois la restriction levÃ©e.`,
          `------------------------------`
      ].join('\n');
      

        await client.sendMessage(target, warningMessage);
        console.log(`ğŸ“© Private mute warning sent to ${target} for ${durationText}`);

              // â”€â”€â”€ schedule auto-unmute â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              setTimeout(async () => {
                try {
                    // Remove from in-memory map
                    mutedUsers.delete(target);
            
                    // Remove from Firestore
                    await removeMutedUser(target);
            
                    // Log unmute action
                    console.log(`âœ… User @${target.split('@')[0]} automatically unmuted after timeout.`);
            
                    // Send a message to the user informing that the restriction has been lifted
                    const unmuteMessage = [
                        `âœ… ×”××’×‘×œ×” ×¢×œ ×©×œ×™×—×ª ×”×•×“×¢×•×ª ×”×•×¡×¨×”.`,
                        `ğŸ’¬ ×›×¢×ª ×‘××¤×©×¨×•×ª×š ×œ×”××©×™×š ×œ×”×©×ª×ª×£ ×‘×§×‘×•×¦×”.`,
                        `------------------------------`,
                         `ğŸ”“ Your restriction from sending messages has been lifted.`,
                        `ğŸ’¬ You may now continue participating in the group.`,
                        `------------------------------`,
                        `âœ… ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºÑƒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ ÑĞ½ÑÑ‚Ğ¾.`,
                        `ğŸ’¬ Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ ÑƒÑ‡Ğ°ÑÑ‚Ğ¸Ğµ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ.`,
                        `------------------------------`,
                        `âœ… La restriction d'envoi de messages a Ã©tÃ© levÃ©e.`,
                        `ğŸ’¬ Vous pouvez maintenant continuer Ã  participer au groupe.`,
                        `------------------------------`
                    ].join('\n');
            
                    // Send the unmute message to the user
                    await client.sendMessage(target, unmuteMessage);
                    console.log(`ğŸ“© Unmute notification sent to @${target.split('@')[0]}`);
                } catch (err) {
                    console.error(`âŒ Failed to send unmute message: ${err.message}`);
                }
            }, muteDurationMs);
            

    } catch (err) {
        console.error('âŒ Mute error:', err.message);
        await msg.reply('âŒ Failed to mute the user.');
    }
    return;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #botkick COMMAND (Fixed for LID) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if (cmd === '#botkick') {
  try {
      const chat = await msg.getChat();
      if (!chat.isGroup) {
          await msg.reply('âš ï¸ This command can only be used in groups.');
          return;
      }

      // Check if the user who sent the command is an admin
      const sender = await msg.getContact();
      const senderJid = getParticipantJid(sender);

      const isAdmin = chat.participants.some(p => {
          const pJid = getParticipantJid(p);
          return pJid === senderJid && p.isAdmin;
      });
    
      if (!isAdmin) {
          await msg.reply('ğŸš« You must be an admin to execute this command.');
          return;
      }

      // Check if bot is admin - find bot by checking isMe property
      let botIsAdmin = false;
      for (const p of chat.participants) {
          try {
              const contact = await client.getContactById(getParticipantJid(p));
              if (contact.isMe && p.isAdmin) {
                  botIsAdmin = true;
                  break;
              }
          } catch (e) {
              // Continue checking
          }
      }

      if (!botIsAdmin) {
          await msg.reply('âš ï¸ The bot must be an admin to kick users.');
          return;
      }

      let kickedUsers = [];
      for (const participant of chat.participants) {
        const participantJid = getParticipantJid(participant);
        if (!participantJid) continue;
        
        const contact = await client.getContactById(participantJid).catch(() => null);
        const userLabel = describeContact(contact);

        if (!await isBlacklisted(participantJid)) continue;

        // don't kick other admins
        if (participant.isAdmin) {
          console.log(`[${getTimestamp()}] âš ï¸ Cannot kick admin user: ${userLabel}`);
          await client.sendMessage(
            `${ALERT_PHONE}@c.us`,
            `âš ï¸ Cannot kick blacklisted user ${userLabel}: user is an admin.`
          );
          continue;
        }

        try {
          // remove them
          await chat.removeParticipants([participantJid]);

          // assume success if no exception
          kickedUsers.push(userLabel);

          // DM them the kick notice
          const kickMessage = [
            'ğŸš« ×”×•×¡×¨×ª ××”×§×‘×•×¦×” ××›×™×•×•×Ÿ ×©××–×”×” ×”××©×ª××© ×©×œ×š ××•×¤×™×¢ ×‘×¨×©×™××” ×”×©×—×•×¨×”.',
            'â— ×× ××ª×” ×—×•×©×‘ ×©××“×•×‘×¨ ×‘×˜×¢×•×ª, × × ×œ×©×œ×•×— ×”×•×“×¢×ª ×ª×’×•×‘×” ×¢×œ ×”×•×“×¢×” ×–×•.',
            'ğŸ”“ ×”×× ×”×œ ×™×‘×“×•×§ ××ª ×‘×§×©×ª×š.'
          ].join('\n');
          await client.sendMessage(participantJid, kickMessage);

          console.log(`[${getTimestamp()}] âœ… Kicked blacklisted user: ${userLabel}`);
        } catch (err) {
          console.error(`[${getTimestamp()}] âŒ Failed to kick ${userLabel}:`, err.message);
          await client.sendMessage(
            `${ALERT_PHONE}@c.us`,
            `âŒ Failed to kick blacklisted user ${userLabel}: ${err.message}`
          );
        }
      }
      

      // Prepare and send the summary message to the ALERT_PHONE
      const alertMessage = kickedUsers.length > 0
          ? [
              'ğŸš¨ *Spam Kick Report:*',
              `âœ… Removed ${kickedUsers.length} blacklisted users from group: ${chat.name}`,
              `ğŸ“Œ Kicked Users:`,
              ...kickedUsers.map(label => `- ${label}`)
          ].join('\n')
          : [
              'ğŸš¨ *Spam Kick Report:*',
              `âœ… No blacklisted users found in the group: ${chat.name}`
          ].join('\n');

      await client.sendMessage(`${ALERT_PHONE}@c.us`, alertMessage);
      
      // If users were kicked, send unblacklist info
      if (kickedUsers.length > 0) {
          await client.sendMessage(`${ALERT_PHONE}@c.us`, 
              'ğŸ”„ To unblacklist any user, use the format:\n#unblacklist [number or JID]');
      }

  } catch (err) {
      console.error('âŒ Error executing #botkick:', err.message);
      await msg.reply('ğŸš« Failed to complete the spam check.');
  }
  return;
}



  if (cleaned === '#commands') {
    try {
      // Check if there are any loaded commands
      if (Object.keys(cachedCommands).length === 0) {
        await msg.reply('ğŸ“ No custom commands available.');
        return;
      }

      // Prepare the list of dynamic commands from Firestore
      const dynamicCommands = Object.keys(cachedCommands).map(cmd => 
        `- ${cmd} - ${cachedCommands[cmd].description || 'No description'}`
      ).join('\n');

      const response = [
        'ğŸ“ *Custom Commands:*',
        dynamicCommands
      ].join('\n');

      // Reply with the list of loaded commands
      await msg.reply(response);
    } catch (e) {
      console.error(`[${getTimestamp()}] âŒ Error fetching custom commands:`, e);
      await msg.reply('ğŸš« Failed to retrieve custom commands.');
    }
    return;
  }


//GETS LIST HELP
if (cleaned === '#help') {
  try {
    // Prepare a list of available commands
    const builtInCommands = [
      'ğŸ“ *Available Commands:*',
      '',
      '*ğŸ”§ Admin Commands:*',
      '1. *#status* - Check the current status of the bot',
      '2. *#reload* - Reload all commands from Firestore',
      '3. *#whitelist [number]* - Add a number to the whitelist\n   (e.g., #whitelist 972555123456)',
      '4. *#unwhitelist [number]* - Remove a number from the whitelist\n   (e.g., #unwhitelist 972555123456)',
      '5. *#whitelst* - List all whitelisted numbers',
      '',
      '*ğŸš« Blacklist Commands:*',
      '6. *#blacklist [number]* - Manually add a number to the blacklist\n   (e.g., #blacklist 972555123456)',
      '7. *#unblacklist [number]* - Remove a number from the blacklist\n   (e.g., #unblacklist 972555123456)',
      '8. *#blacklst* - List all blacklisted numbers',
      '',
      '*ğŸš¨ Group Management Commands:*',
      '9. *#kick* - Kick a user from the group (reply to a message)',
      '10. *#cf* - Check for foreign numbers in the group',
      '11. *#mute [minutes]* - Mute the entire group for the specified number of minutes\n    (admin only)',
      '12. *#mute (reply) [minutes]* - Mute a specific user for the specified number of minutes\n    (admin only), kicked out if they send more than 3 messages while muted',
      '13. *#botkick* - Automatically kick out all blacklisted users from the current group',
      '14. *#warn* - Send a warning to a user (reply to their message, admin only)',
      '15. *#clear* - Delete last 10 messages from a user (reply to their message OR use #clear [JID/number])',
      '16. *#cleartest* - Test bot\'s message deletion capabilities (admin only)',
      '17. *#cleardebug* - Debug message author detection (reply to message)',
      '',
      '*ğŸ‘‘ Super Admin Commands:*',
      '18. *#promote* - Promote a user to admin (reply to their message, super admin only)',
      '19. *#demote* - Demote an admin to regular user (reply to their message, super admin only)',
      '',
      '*ğŸ“¢ Communication Commands:*',
      '20. *#announce [message]* - Send an announcement to all group members (admin only)',
      '21. *#pin [days]* - Pin a message (reply to message, default 7 days, admin only)',
      '22. *#translate* - Translate a message to Hebrew (reply to message or provide text)',
      '',
      '*ğŸ“Š Information Commands:*',
      '23. *#stats* - Show group statistics (member count, admin count, etc.)',
      '24. *#commands* - Display all loaded custom commands from Firestore',
      '25. *#help* - Show this help message',
      '',
      '*ğŸ”„ Recovery Commands:*',
      '26. *#unb [number]* - Unban a previously banned number\n    (e.g., #unb 972555123456), must be as a reply to a bot message',
      '',
      'ğŸ’¡ *Note:* Use these commands responsibly to ensure group safety and proper user behavior.',
      'âš ï¸ *WhatsApp URLs:* When someone posts a WhatsApp group link, they are automatically kicked and blacklisted.',
    ];

    // Add dynamically loaded commands from Firestore
    const dynamicCommands = Object.keys(cachedCommands).map(cmd => `- ${cmd} - ${cachedCommands[cmd].description}`);
    const allCommands = builtInCommands.concat(dynamicCommands);

    // Construct the response message
    const response = [
      'ğŸ“ *Available Commands:*',
      ...allCommands
    ].join('\n');

    // Reply with the list of commands
    await msg.reply(response);
  } catch (e) {
    console.error(`[${getTimestamp()}] âŒ Error fetching commands:`, e);
    await msg.reply('ğŸš« Failed to retrieve the command list.');
  }
  return;
}

// Inside your unified message_create handler
if (msg.from === `${ALERT_PHONE}@c.us` && cleaned === '#status') {
  const uptimeMs = Date.now() - startTime;
  const uptimeHours = Math.floor(uptimeMs / 3600000);
  const uptimeMins = Math.floor((uptimeMs % 3600000) / 60000);
  const cmdsLoaded = Object.keys(cachedCommands).length;
  const autoReload = false;  // We decided not to auto-reload
  const activeGroups = (await client.getChats()).filter(chat => chat.isGroup).length;

  // Get the number of whitelisted numbers
  const whitelistCount = await listWhitelist().then(list => list.length);

  const status = [
      'ğŸ¤– Bot Status:',
      `- â±ï¸ Uptime: ${uptimeHours} hours ${uptimeMins} minutes`,
      `- ğŸŸ¢ Active Groups: ${activeGroups}`,
      `- ğŸ“‹ Commands Loaded: ${cmdsLoaded}`,
      `- ğŸ”„ Auto-reload: ${autoReload ? 'On' : 'Off'}`,
      `- âœ… Whitelisted Numbers: ${whitelistCount}`
  ].join('\n');

  await msg.reply(status);
  return;
}


  /* ------------------------------------------------------------------
     1) ADMIN-ONLY COMMANDS  (must come from ALERT_PHONE chat)
  ------------------------------------------------------------------ */
  if (msg.from === `${ALERT_PHONE}@c.us`) {

      // â”€â”€â”€ Manual "unb" via reply â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (msg.hasQuotedMsg && lowered === '#unb') {
    // 1) fetch the quoted message
    const quoted = await msg.getQuotedMessage();
    // 2) extract the phone number from the alert text
    const m = quoted.body.match(/Number:\s*\+?(\d+)/);
    if (!m) {
      await msg.reply('âš ï¸ ×œ× ××¦××ª×™ ××¡×¤×¨ ×‘×˜×§×¡×˜ ×”××¦×•×˜×˜ ×›×“×™ ×œ×”×¡×™×¨ ××”×¨×©×™××” ×”×©×—×•×¨×”.');
      return;
    }
    const phone = m[1];  // e.g. "972555123456"
    // 3) remove from blacklist
    if (await removeFromBlacklist(phone)) {
      await msg.reply(`âœ… ×”××¡×¤×¨ +${phone} ×”×•×¡×¨ ××”×¨×©×™××” ×”×©×—×•×¨×”.`);
    } else {
      await msg.reply(`â„¹ï¸ ×”××¡×¤×¨ +${phone} ×œ× × ××¦× ×‘×¨×©×™××” ×”×©×—×•×¨×”.`);
    }
    return;
  }


  
    switch (cmd) {

      // ğŸ”„ reload Firestore-defined commands
      case '#reload':
        await loadCommands();
        await msg.reply([
          'ğŸ”„ Command Reload',
          'âœ… Commands reloaded successfully!'
        ].join('\n'));
        return;

      // âœ… add number to whitelist
      case '#whitelist':
        if (!arg) {
          await msg.reply([
            'âš ï¸ Whitelist Command Error',
            'ğŸš« Missing phone number.',
            'ğŸ’¡ Usage: #whitelist 972555123456'
          ].join('\n'));
          return;
        }
        const targetJid = jidKey(arg);
        if (!targetJid) {
          await msg.reply('âš ï¸ Invalid identifier. Please supply a valid JID or phone number.');
          return;
        }

        if (await addToWhitelist(targetJid)) {
          await msg.reply([
            'âœ… Whitelist Update',
            `ğŸ‘¤ ID: ${targetJid}`,
            'ğŸ“ Status: Added to whitelist'
          ].join('\n'));
        } else {
          await msg.reply([
            'â„¹ï¸ Whitelist Info',
            `ğŸ‘¤ ID: ${targetJid}`,
            'ğŸ“ Status: Already whitelisted'
          ].join('\n'));
        }
        return;

      // âœ… remove number from whitelist
      case '#unwhitelist':
        if (!arg) {
          await msg.reply([
            'âš ï¸ Unwhitelist Command Error',
            'ğŸš« Missing phone number.',
            'ğŸ’¡ Usage: #unwhitelist 972555123456'
          ].join('\n'));
          return;
        }
        const targetJidUW = jidKey(arg);
        if (!targetJidUW) {
          await msg.reply('âš ï¸ Invalid identifier. Please supply a valid JID or phone number.');
          return;
        }

        if (await removeFromWhitelist(targetJidUW)) {
          await msg.reply([
            'âœ… Whitelist Update',
            `ğŸ‘¤ ID: ${targetJidUW}`,
            'ğŸ“ Status: Removed from whitelist'
          ].join('\n'));
        } else {
          await msg.reply([
            'âš ï¸ Whitelist Info',
            `ğŸ‘¤ ID: ${targetJidUW}`,
            'ğŸš« Status: Not found in whitelist'
          ].join('\n'));
        }
        return;

      // ğŸ“‹ list all whitelisted numbers
      case '#whitelst':
        const numbers = await listWhitelist();
        await msg.reply(
          numbers.length
            ? ['ğŸ“ Whitelisted Numbers:', ...numbers.map(n => `- ${n}`)].join('\n')
            : ['ğŸ“ Whitelist Status', 'ğŸš« No numbers are currently whitelisted.'].join('\n')
        );
        return;
      // âœ… add number to blacklist
        case '#blacklist':
          if (!arg) {
            await msg.reply([
              'âš ï¸ Blacklist Command Error',
              'ğŸš« Missing phone number.',
              'ğŸ’¡ Usage: #blacklist 972555123456'
            ].join('\n'));
            return;
          }
          const targetJidBL = jidKey(arg);
          if (!targetJidBL) {
            await msg.reply('âš ï¸ Invalid identifier. Please supply a valid JID or phone number.');
            return;
          }

          if (await addToBlacklist(targetJidBL)) {
            await msg.reply([
              'âœ… Blacklist Update',
              `ğŸ‘¤ ID: ${targetJidBL}`,
              'ğŸš« Status: Added to blacklist'
            ].join('\n'));
            console.log(`âœ… Manually blacklisted: ${targetJidBL}`);
          } else {
            await msg.reply([
              'â„¹ï¸ Blacklist Info',
              `ğŸ‘¤ ID: ${targetJidBL}`,
              'ğŸš« Status: Already blacklisted'
            ].join('\n'));
          }
          return;

          // âœ… remove number from blacklist
          case '#unblacklist':
            if (!arg) {
              await msg.reply([
                'âš ï¸ Unblacklist Command Error',
                'ğŸš« Missing phone number.',
                'ğŸ’¡ Usage: #unblacklist 972555123456'
              ].join('\n'));
              return;
            }
            const targetJidUBL = jidKey(arg);
            if (!targetJidUBL) {
              await msg.reply('âš ï¸ Invalid identifier. Please supply a valid JID or phone number.');
              return;
            }

            if (await removeFromBlacklist(targetJidUBL)) {
              await msg.reply([
                'âœ… Blacklist Update',
                `ğŸ‘¤ ID: ${targetJidUBL}`,
                'ğŸ“ Status: Removed from blacklist'
              ].join('\n'));
              console.log(`âœ… Manually unblacklisted: ${targetJidUBL}`);
            } else {
              await msg.reply([
                'âš ï¸ Blacklist Info',
                `ğŸ‘¤ ID: ${targetJidUBL}`,
                'ğŸš« Status: Not found in blacklist'
              ].join('\n'));
            }
            return;

            // ğŸ“‹ list all blacklisted numbers
            case '#blacklst':
              const blacklistedNumbers = await listBlacklist();
              await msg.reply(
                blacklistedNumbers.length
                  ? ['ğŸ“ Blacklisted Numbers:', ...blacklistedNumbers.map(n => `- ${n}`)].join('\n')
                  : ['ğŸ“ Blacklist Status', 'ğŸš« No numbers are currently blacklisted.'].join('\n')
              );
              return;

            }
  }

  /* ------------------------------------------------------------------
     2) FIRESTORE CUSTOM COMMANDS  (anyone can trigger)
  ------------------------------------------------------------------ */
  if (cachedCommands[lowered]) {
    await msg.reply(`ğŸ“ ${cachedCommands[lowered].description}`);
    return;
  }

  /* ------------------------------------------------------------------
     3) FOREIGN-CHECK  (#cf) â€“ typed by the bot account inside group
  ------------------------------------------------------------------ */
  if (msg.fromMe && lowered === '#cf') {
    const chat = await msg.getChat().catch(() => null);
    if (!chat?.isGroup) {
      await msg.reply('â›” ×¦×¨×™×š ×œ×©×œ×•×— ××ª ×”×¤×§×•×“×” ×‘×ª×•×š ×§×‘×•×¦×”.');
      return;
    }
    // Check if bot is admin - find bot by checking isMe property
    let botIsAdmin = false;
    for (const p of chat.participants) {
        try {
            const contact = await client.getContactById(getParticipantJid(p));
            if (contact.isMe && p.isAdmin) {
                botIsAdmin = true;
                break;
            }
        } catch (e) {
            // Continue checking
        }
    }
    if (!botIsAdmin) {
      await msg.reply('âš ï¸ ×”×‘×•×˜ ×œ× ××“××™×Ÿ ×‘×§×‘×•×¦×” ×”×–×•.');
      return;
    }

    const foreign = [];
    for (const p of chat.participants) {
      const c = await client.getContactById(getParticipantJid(p)).catch(() => null);
      if (c?.number && !c.number.startsWith('972')) {
        foreign.push(`â€¢ ${c.pushname || '×œ× ×™×“×•×¢'} (${c.number})`);
      }
    }
    await msg.reply(
      foreign.length
        ? `ğŸŒ ×–×•×”×• ××¡×¤×¨×™× ×–×¨×™×:\n${foreign.join('\n')}`
        : 'âœ… ×œ× × ××¦××• ××¡×¤×¨×™× ×–×¨×™×.'
    );
    return;
  }

  /* ------------------------------------------------------------------
     4) UPGRADED #kick (reply, from bot account) - Fixed for LID
  ------------------------------------------------------------------ */
/* â”€â”€â”€â”€â”€â”€â”€ #kick â€“ delete replied msg, kick user, DM admin with group URL â”€â”€â”€â”€â”€â”€â”€ */
if (msg.fromMe && cmd === '#kick' && msg.hasQuotedMsg) {
  const chat   = await msg.getChat().catch(() => null);
  const quoted = await msg.getQuotedMessage().catch(() => null);
  if (!chat?.isGroup || !quoted) return;

  // 1) Determine the target JID with LID support
  const target = getMessageAuthor(quoted);
  if (!target) {
    console.log(`[${getTimestamp()}] âŒ Could not determine target user for kick`);
    return;
  }

  // 2) Delete only the replied-to message
  try { await quoted.delete(true); } catch { /* ignore */ }

  // 3) Kick the user
  try { 
    await chat.removeParticipants([target]); 
    console.log(`[${getTimestamp()}] âœ… Kicked user: ${target}`);
  } catch (err) { 
    console.error(`[${getTimestamp()}] âŒ Failed to kick user:`, err.message);
  }

  // 4) Build Group URL
  const inviteCode = await chat.getInviteCode().catch(() => null);
  const groupURL = inviteCode
    ? `https://chat.whatsapp.com/${inviteCode}`
    : '[URL unavailable]';

  // 5) Send alert *only* to ALERT_PHONE
  const alert = [
    'ğŸš¨ User Kicked',
    `ğŸ‘¤ Number: ${target}`,
    `ğŸ“ Group: ${chat.name}`,
    `ğŸ”— Group URL: ${groupURL}`,
    'ğŸ—‘ï¸ Message Deleted: 1',
    'ğŸš« User was removed.'
  ].join('\n');

  await client.sendMessage(`${ALERT_PHONE}@c.us`, alert).catch(() => {});
  return;
}

if (cmd === '#translate') {
  let textToTranslate = '';
  let targetContact = null;
  let detectedLang = 'unknown';

  // Try to get the quoted message if available
  if (msg.hasQuotedMsg) {
      try {
          const quoted = await msg.getQuotedMessage();
          textToTranslate = quoted.body;
          targetContact = getMessageAuthor(quoted);
      } catch (e) {
          await msg.reply('âš ï¸ Could not retrieve the quoted message for translation.');
          return;
      }
  } else {
      textToTranslate = arg || msg.body.replace(/^#translate/i, '').trim();
      targetContact = getMessageAuthor(msg);
  }

  if (!textToTranslate) {
      await msg.reply('âš ï¸ No text to translate.');
      return;
  }

  try {
      // Attempt to translate the text
      const translationResult = await translate(textToTranslate, { to: 'he' });
      const translatedText = translationResult.text || '×œ× ×–×•×”×” ×ª×¨×’×•×';

      // Detect language
      if (translationResult.from?.language?.iso) {
          detectedLang = translationResult.from.language.iso;
      } else if (translationResult.raw?.src) {
          detectedLang = translationResult.raw.src;
      }

      // Only translate if not Hebrew, else still show result
      if (detectedLang !== 'he') {
          await msg.reply(
              `ğŸŒ ×ª×¨×’×•× ××”××©×ª××© @${(targetContact || '').split('@')[0]} (×${detectedLang}):\n${translatedText}`
          );
      } else {
          await msg.reply(`ğŸŒ ×”×˜×§×¡×˜ ×›×‘×¨ ×‘×¢×‘×¨×™×ª:\n${translatedText}`);
      }
      console.log(`[${getTimestamp()}] âœ… Translated from ${detectedLang}: ${translatedText}`);
  } catch (err) {
      console.error('âŒ Translation failed:', err.message);
      await msg.reply('ğŸš« Translation error: Unable to process the message.');
  }
  return;
}

// â”€â”€â”€â”€â”€â”€â”€ #warn â€“ Send warning to user (reply to message) â”€â”€â”€â”€â”€â”€â”€
if (msg.hasQuotedMsg && cmd === '#warn') {
    try {
        const chat = await msg.getChat();
        const sender = await msg.getContact();
        
        if (!chat.isGroup) {
            await msg.reply('âš ï¸ This command can only be used in groups.');
            return;
        }
        
        const senderJid = getParticipantJid(sender);
        const isAdmin = chat.participants.some(p => {
            const pJid = getParticipantJid(p);
            return pJid === senderJid && p.isAdmin;
        });
        
        if (!isAdmin) {
            await msg.reply('ğŸš« You must be an admin to warn users.');
            return;
        }
        
        const quotedMsg = await msg.getQuotedMessage();
        const target = getMessageAuthor(quotedMsg);
        
        if (!target) {
            await msg.reply('âš ï¸ Unable to identify the user to warn.');
            return;
        }
        
        const warningMessage = [
            'âš ï¸ *WARNING*',
            'Your behavior violates group rules. Please follow the group guidelines.',
            'Further violations may result in mute or removal from the group.',
            '------------------------------',
            'âš ï¸ *××–×”×¨×”*',
            '×”×”×ª× ×”×’×•×ª ×©×œ×š ××¤×¨×” ××ª ×›×œ×œ×™ ×”×§×‘×•×¦×”. ×× × ×¢×§×•×‘ ××—×¨ ×”×”× ×—×™×•×ª.',
            '×”×¤×¨×•×ª × ×•×¡×¤×•×ª ×¢×œ×•×œ×•×ª ×œ×’×¨×•× ×œ×”×©×ª×§×” ××• ×”×¡×¨×” ××”×§×‘×•×¦×”.'
        ].join('\n');
        
        await client.sendMessage(target, warningMessage);
        await msg.reply(`âš ï¸ Warning sent to @${target.split('@')[0]}`);
        console.log(`[${getTimestamp()}] âš ï¸ Warning sent to ${target}`);
    } catch (err) {
        console.error('âŒ Warning error:', err.message);
        await msg.reply('âŒ Failed to send warning.');
    }
    return;
}

// â”€â”€â”€â”€â”€â”€â”€ #stats â€“ Show group statistics â”€â”€â”€â”€â”€â”€â”€
if (cmd === '#stats') {
    try {
        const chat = await msg.getChat();
        if (!chat.isGroup) {
            await msg.reply('âš ï¸ This command can only be used in groups.');
            return;
        }
        
        const totalMembers = chat.participants.length;
        const adminCount = chat.participants.filter(p => p.isAdmin).length;
        const regularMembers = totalMembers - adminCount;
        
        const stats = [
            'ğŸ“Š *Group Statistics*',
            `ğŸ‘¥ Total Members: ${totalMembers}`,
            `ğŸ‘‘ Admins: ${adminCount}`,
            `ğŸ‘¤ Regular Members: ${regularMembers}`,
            `ğŸ·ï¸ Group Name: ${chat.name}`,
            `ğŸ†” Group ID: ${chat.id._serialized}`
        ].join('\n');
        
        await msg.reply(stats);
    } catch (err) {
        console.error('âŒ Stats error:', err.message);
        await msg.reply('âŒ Failed to get group statistics.');
    }
    return;
}

// â”€â”€â”€â”€â”€â”€â”€ #clear â€“ Clear messages from a specific user (admin only) â”€â”€â”€â”€â”€â”€â”€
if (msg.hasQuotedMsg && cmd === '#clear') {
    const chat = await msg.getChat().catch(() => null);
    const quotedMsg = await msg.getQuotedMessage().catch(() => null);
    
    if (!chat?.isGroup || !quotedMsg) {
        await msg.reply('âš ï¸ This command requires a group and quoted message.');
        return;
    }
    
    // Check if sender is admin
    const sender = await msg.getContact();
    const senderJid = getParticipantJid(sender);
    const isAdmin = chat.participants.some(p => {
        const pJid = getParticipantJid(p);
        return pJid === senderJid && p.isAdmin;
    });
    
    if (!isAdmin) {
        await msg.reply('ğŸš« You must be an admin to clear messages.');
        return;
    }
    
    // Check if bot is admin (same logic as other commands)
    let botIsAdmin = false;
    for (const p of chat.participants) {
        try {
            const contact = await client.getContactById(getParticipantJid(p));
            if (contact.isMe && p.isAdmin) {
                botIsAdmin = true;
                break;
            }
        } catch (e) {
            // Continue
        }
    }
    
    if (!botIsAdmin) {
        await msg.reply('âš ï¸ The bot must be an admin to delete messages.');
        return;
    }
    
    // Get target using SAME logic as #kick command
    const target = getMessageAuthor(quotedMsg);
    if (!target) {
        await msg.reply('âš ï¸ Could not determine target user.');
        return;
    }
    
    console.log(`[${getTimestamp()}] #clear target: ${target}`);
    
    try {
        // Step 1: Delete the quoted message (we know this works)
        console.log(`[${getTimestamp()}] Deleting quoted message...`);
        try {
            await quotedMsg.delete(true);
            console.log(`[${getTimestamp()}] âœ… Quoted message deleted`);
        } catch (e) {
            console.log(`[${getTimestamp()}] âŒ Failed to delete quoted message: ${e.message}`);
        }
        
        // Step 2: Find and delete recent messages (last 20 messages only for better success rate)
        console.log(`[${getTimestamp()}] Finding recent messages...`);
        const messages = await chat.fetchMessages({ limit: 20 }); // Only recent messages
        
        let deletedCount = 1; // Count the quoted message
        let foundCount = 0;
        
        // Process messages in reverse order (newest first)
        for (let i = 0; i < messages.length; i++) {
            const message = messages[i];
            const messageAuthor = getMessageAuthor(message);
            
            // Skip if not from target, is command, or is already deleted quoted message
            if (messageAuthor !== target || 
                message.id.id === msg.id.id || 
                message.id.id === quotedMsg.id.id) {
                continue;
            }
            
            foundCount++;
            
            // Only try to delete the most recent messages (better chance of success)
            if (foundCount <= 9) { // Plus the quoted message = 10 total
                try {
                    console.log(`[${getTimestamp()}] Deleting recent message ${foundCount}: ${message.body?.substring(0, 30) || '[media]'}`);
                    
                    // Check message age (only delete recent messages)
                    const messageAge = Date.now() - (message.timestamp * 1000);
                    const oneHour = 60 * 60 * 1000;
                    
                    if (messageAge < oneHour) {
                        // Recent message - should delete successfully
                        await message.delete(true);
                        deletedCount++;
                        console.log(`[${getTimestamp()}] âœ… Deleted recent message ${foundCount}`);
                    } else {
                        // Old message - try but might not work
                        console.log(`[${getTimestamp()}] âš ï¸ Message is ${Math.round(messageAge / (1000 * 60))} minutes old`);
                        await message.delete(true);
                        deletedCount++;
                        console.log(`[${getTimestamp()}] âœ… Deleted old message ${foundCount}`);
                    }
                    
                    // Delay between deletions
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (e) {
                    console.error(`[${getTimestamp()}] âŒ Failed to delete message ${foundCount}: ${e.message}`);
                }
            }
        }
        
        console.log(`[${getTimestamp()}] Clear completed: ${deletedCount} messages processed, ${foundCount} found`);
        
        if (deletedCount > 0) {
        //    await msg.reply(`ğŸ§¹ Deleted ${deletedCount} messages from @${target.split('@')[0]}`);
        } else {
        //    await msg.reply(`âš ï¸ No messages found to delete from @${target.split('@')[0]}`);
        }
        
    } catch (err) {
        console.error(`[${getTimestamp()}] âŒ Clear error:`, err.message);
        await msg.reply('âŒ Failed to clear messages.');
    }
    
    return;
}

// â”€â”€â”€â”€â”€â”€â”€ #promote â€“ Promote user to admin (super admin only) â”€â”€â”€â”€â”€â”€â”€
if (msg.hasQuotedMsg && cmd === '#promote') {
    try {
        const chat = await msg.getChat();
        const sender = await msg.getContact();
        
        if (!chat.isGroup) {
            await msg.reply('âš ï¸ This command can only be used in groups.');
            return;
        }
        
        // Only ADMIN_PHONE can promote
        if (sender.number !== ADMIN_PHONE) {
            await msg.reply('ğŸš« Only the super admin can promote users.');
            return;
        }
        
        const quotedMsg = await msg.getQuotedMessage();
        const target = getMessageAuthor(quotedMsg);
        
        if (!target) {
            await msg.reply('âš ï¸ Unable to identify the user to promote.');
            return;
        }
        
        await chat.promoteParticipants([target]);
        await msg.reply(`âœ… @${target.split('@')[0]} has been promoted to admin.`);
        console.log(`[${getTimestamp()}] ğŸ‘‘ Promoted ${target} to admin`);
    } catch (err) {
        console.error('âŒ Promote error:', err.message);
        await msg.reply('âŒ Failed to promote user.');
    }
    return;
}

// â”€â”€â”€â”€â”€â”€â”€ #demote â€“ Demote admin to regular user (super admin only) â”€â”€â”€â”€â”€â”€â”€
if (msg.hasQuotedMsg && cmd === '#demote') {
    try {
        const chat = await msg.getChat();
        const sender = await msg.getContact();
        
        if (!chat.isGroup) {
            await msg.reply('âš ï¸ This command can only be used in groups.');
            return;
        }
        
        // Only ADMIN_PHONE can demote
        if (sender.number !== ADMIN_PHONE) {
            await msg.reply('ğŸš« Only the super admin can demote users.');
            return;
        }
        
        const quotedMsg = await msg.getQuotedMessage();
        const target = getMessageAuthor(quotedMsg);
        
        if (!target) {
            await msg.reply('âš ï¸ Unable to identify the user to demote.');
            return;
        }
        
        await chat.demoteParticipants([target]);
        await msg.reply(`âœ… @${target.split('@')[0]} has been demoted from admin.`);
        console.log(`[${getTimestamp()}] ğŸ‘¤ Demoted ${target} from admin`);
    } catch (err) {
        console.error('âŒ Demote error:', err.message);
        await msg.reply('âŒ Failed to demote user.');
    }
    return;
}

// â”€â”€â”€â”€â”€â”€â”€ #announce â€“ Send announcement to all members â”€â”€â”€â”€â”€â”€â”€
if (cmd === '#announce') {
    try {
        const chat = await msg.getChat();
        const sender = await msg.getContact();
        
        if (!chat.isGroup) {
            await msg.reply('âš ï¸ This command can only be used in groups.');
            return;
        }
        
        const senderJid = getParticipantJid(sender);
        const isAdmin = chat.participants.some(p => {
            const pJid = getParticipantJid(p);
            return pJid === senderJid && p.isAdmin;
        });
        
        if (!isAdmin) {
            await msg.reply('ğŸš« You must be an admin to send announcements.');
            return;
        }
        
        if (!arg) {
            await msg.reply('âš ï¸ Please provide an announcement message.');
            return;
        }
        
        const announcement = [
            'ğŸ“¢ *GROUP ANNOUNCEMENT*',
            'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”',
            arg,
            'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”',
            `From: @${sender.number}`
        ].join('\n');
        
        await chat.sendMessage(announcement, { mentions: [sender] });
        console.log(`[${getTimestamp()}] ğŸ“¢ Announcement sent by ${sender.pushname}`);
    } catch (err) {
        console.error('âŒ Announce error:', err.message);
        await msg.reply('âŒ Failed to send announcement.');
    }
    return;
}

// â”€â”€â”€â”€â”€â”€â”€ #pin â€“ Pin message (admin only) â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€ #cleardebug â€“ Debug message authors â”€â”€â”€â”€â”€â”€â”€
if (msg.hasQuotedMsg && cmd === '#cleardebug') {
    try {
        const chat = await msg.getChat();
        const quotedMsg = await msg.getQuotedMessage();
        
        // Get target from quoted message
        const target = getMessageAuthor(quotedMsg);
        const targetJid = jidKey(target);
        
        console.log(`[${getTimestamp()}] === CLEAR DEBUG ===`);
        console.log(`[${getTimestamp()}] Quoted message author: ${target}`);
        console.log(`[${getTimestamp()}] Normalized target JID: ${targetJid}`);
        
        // Fetch recent messages
        const messages = await chat.fetchMessages({ limit: 20 });
        
        let debugInfo = 'ğŸ” *Clear Debug Info*\n\n';
        debugInfo += `Target: ${target}\n`;
        debugInfo += `Normalized: ${targetJid}\n\n`;
        
        let matchCount = 0;
        const matchedMessages = [];
        
        // First pass: count all matches
        for (let i = 0; i < messages.length; i++) {
            const message = messages[i];
            const author = getMessageAuthor(message);
            const authorJid = jidKey(author);
            const isMatch = authorJid === targetJid;
            
            if (isMatch) {
                matchCount++;
                matchedMessages.push({ index: i + 1, message, author, authorJid });
            }
        }
        
        debugInfo += `*Total Matches: ${matchCount}*\n\n`;
        
        // Show matched messages
        if (matchedMessages.length > 0) {
            debugInfo += '*Matched Messages:*\n';
            matchedMessages.slice(0, 10).forEach((match, idx) => {
                debugInfo += `${idx + 1}. Message #${match.index}\n`;
                debugInfo += `   Author: ${match.author}\n`;
                debugInfo += `   Body: ${match.message.body?.substring(0, 30) || '[media]'}...\n\n`;
            });
            if (matchedMessages.length > 10) {
                debugInfo += `... and ${matchedMessages.length - 10} more\n\n`;
            }
        }
        
        debugInfo += '*First 10 Messages (for reference):*\n';
        for (let i = 0; i < Math.min(10, messages.length); i++) {
            const message = messages[i];
            const author = getMessageAuthor(message);
            const authorJid = jidKey(author);
            const isMatch = authorJid === targetJid;
            
            debugInfo += `${i + 1}. Author: ${author}\n`;
            debugInfo += `   Match: ${isMatch ? 'âœ…' : 'âŒ'}\n`;
            debugInfo += `   Body: ${message.body?.substring(0, 20) || '[media]'}...\n\n`;
        }
        
        await msg.reply(debugInfo);
        console.log(`[${getTimestamp()}] Debug info sent`);
        
    } catch (err) {
        console.error('âŒ Clear debug error:', err.message);
        await msg.reply('âŒ Failed to debug clear command.');
    }
    return;
}


// â”€â”€â”€â”€â”€â”€â”€ #cleartest â€“ Test message deletion capabilities â”€â”€â”€â”€â”€â”€â”€
if (cmd === '#cleartest') {
    try {
        const chat = await msg.getChat();
        const sender = await msg.getContact();
        
        if (!chat.isGroup) {
            await msg.reply('âš ï¸ This command can only be used in groups.');
            return;
        }
        
        // Only allow admins to run this test
        const senderJid = getParticipantJid(sender);
        const isAdmin = chat.participants.some(p => {
            const pJid = getParticipantJid(p);
            return pJid === senderJid && p.isAdmin;
        });
        
        if (!isAdmin) {
            await msg.reply('ğŸš« You must be an admin to run clear test.');
            return;
        }
        
        await msg.reply('ğŸ§ª Running message deletion capability test...');
        
        // Test 1: Can bot delete its own message?
        const testMsg = await chat.sendMessage('ğŸ§ª Test message from bot - will try to delete this');
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        let testResults = 'ğŸ“‹ *Clear Command Test Results*\n\n';
        
        try {
            await testMsg.delete(true);
            testResults += 'âœ… Bot can delete its own messages\n';
        } catch (e) {
            testResults += 'âŒ Bot CANNOT delete its own messages\n';
            testResults += `   Error: ${e.message}\n`;
        }
        
        // Test 2: Check bot admin status
        let botIsAdmin = false;
        for (const p of chat.participants) {
            try {
                const contact = await client.getContactById(getParticipantJid(p));
                if (contact.isMe && p.isAdmin) {
                    botIsAdmin = true;
                    break;
                }
            } catch (e) {
                // Continue
            }
        }
        
        testResults += botIsAdmin ? 'âœ… Bot is admin in this group\n' : 'âŒ Bot is NOT admin in this group\n';
        
        // Test 3: Try to delete a recent message from someone else
        const messages = await chat.fetchMessages({ limit: 20 });
        let otherMessage = null;
        
        for (const message of messages) {
            if (!message.fromMe && message.id.id !== msg.id.id) {
                otherMessage = message;
                break;
            }
        }
        
        if (otherMessage) {
            try {
                await otherMessage.delete(true);
                testResults += "âœ… Bot can delete others' messages\n";
            } catch (e) {
                testResults += "âŒ Bot CANNOT delete others' messages\n";
                testResults += `   Error: ${e.message}\n`;
            }
        } else {
            testResults += "â„¹ï¸ No other messages found to test\n";
        }
        
        // Test 4: Message age check
        testResults += '\nğŸ•’ *Message Age Limits:*\n';
        testResults += '- Admins: Can delete any message\n';
        testResults += '- Non-admins: Only messages < 24 hours\n';
        testResults += '- Own messages: Usually deletable anytime\n';
        
        testResults += '\nğŸ’¡ *Recommendations:*\n';
        if (!botIsAdmin) {
            testResults += 'âš ï¸ Make the bot an admin for full functionality\n';
        }
        testResults += '- Use #clear on recent messages only\n';
        testResults += '- Bot must be admin to delete all messages\n';
        
        await msg.reply(testResults);
        
    } catch (err) {
        console.error('âŒ Clear test error:', err.message);
        await msg.reply('âŒ Failed to run clear test.');
    }
    return;
}

if (msg.hasQuotedMsg && cmd === '#pin') {
    try {
        const chat = await msg.getChat();
        const sender = await msg.getContact();
        
        if (!chat.isGroup) {
            await msg.reply('âš ï¸ This command can only be used in groups.');
            return;
        }
        
        const senderJid = getParticipantJid(sender);
        const isAdmin = chat.participants.some(p => {
            const pJid = getParticipantJid(p);
            return pJid === senderJid && p.isAdmin;
        });
        
        if (!isAdmin) {
            await msg.reply('ğŸš« You must be an admin to pin messages.');
            return;
        }
        
        const quotedMsg = await msg.getQuotedMessage();
        const duration = parseInt(arg) || 7; // Default 7 days
        
        await quotedMsg.pin(duration * 24 * 60 * 60); // Convert days to seconds
        await msg.reply(`ğŸ“Œ Message pinned for ${duration} days.`);
        console.log(`[${getTimestamp()}] ğŸ“Œ Message pinned for ${duration} days`);
    } catch (err) {
        console.error('âŒ Pin error:', err.message);
        await msg.reply('âŒ Failed to pin message.');
    }
    return;
}

});


/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ INVITE-LINK MODERATION (Fixed for LID) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
client.on('message', async msg => {
  if (msg.fromMe) return;        
  
   // Ignore messages sent before the bot was started
   const messageTimestamp = msg.timestamp * 1000; // Convert from seconds to milliseconds
   if (messageTimestamp < startTime) {
     console.log(`[${getTimestamp()}] â³ Ignored old message from ${msg.from}`);
     return;
   }
   // skip self-echo
  const chat    = await msg.getChat().catch(() => null);
  const contact = await msg.getContact().catch(() => null);
  if (!chat?.isGroup || !contact) return;

  // Check if user is muted
  const author = getMessageAuthor(msg);
  const muteUntil = mutedUsers.get(author);
  if (muteUntil && Date.now() < muteUntil) {
    // 1) Count this infraction
    const count = (mutedMsgCounts.get(author) || 0) + 1;
    mutedMsgCounts.set(author, count);

    // 2) If over 3 messages while muted â†’ kick
    if (count > 3) {
      try {
        await chat.removeParticipants([author]);
        await chat.sendMessage(
          `ğŸš¨ ×”××©×ª××© @${author.split('@')[0]} ×”×•×¨×—×§ ×‘×©×œ ×”×¤×¨×ª ×›×œ×œ×™ ×”×§×‘×•×¦×”.`
        );
        console.log(`[${getTimestamp()}] âœ… Kicked @${author.split('@')[0]} after ${count} muted messages.`);
      } catch (e) {
        console.error(`[${getTimestamp()}] âŒ Failed to kick user:`, e.message);
      }
      // clean up their state
      mutedUsers.delete(author);
      mutedMsgCounts.delete(author);
      return;
    }

    // 3) Otherwise still under limit â†’ shadow-delete
    try {
      await msg.delete(true);
      console.log(
        `ğŸ—‘ï¸ Shadow-deleted message #${count} from @${author.split('@')[0]} (still muted)`
      );
    } catch (err) {
      console.error(`[${getTimestamp()}] âŒ Failed to delete message:`, err.message);
    }
    return;
  }

  
  const body        = msg.body.replace(/\u200e/g, '').trim(); // keep original case!
  // Updated regex to catch more WhatsApp URL variations
  const inviteRegex = /https?:\/\/(chat\.)?whatsapp\.com\/(chat\/)?([A-Za-z0-9]{10,})/gi;
  const matches     = body.match(inviteRegex) || [];
  
  // Debug logging
  if (body.toLowerCase().includes('whatsapp.com')) {
    console.log(`[${getTimestamp()}] ğŸ” Detected potential WhatsApp link in message from ${msg.from}`);
    console.log(`[${getTimestamp()}] Message body: ${body}`);
    console.log(`[${getTimestamp()}] Matches found: ${matches.length}`);
  }
  
  if (!matches.length) return;
  
  // Extract group codes from URLs
  const groupCodes = [];
  let match;
  while ((match = inviteRegex.exec(body)) !== null) {
    // Extract the group code (last captured group)
    const groupCode = match[3] || match[2] || match[1];
    if (groupCode && groupCode.length >= 10) {
      groupCodes.push(groupCode);
    }
  }

  const contactJid = jidKey(contact);
  const senderIsAdmin = chat.participants.some(p => {
    const pJid = getParticipantJid(p);
    return pJid === contactJid && p.isAdmin;
  });
  
  console.log(`[${getTimestamp()}] ğŸ”— WhatsApp invite detected from ${contactJid}`);
  console.log(`[${getTimestamp()}] Sender is admin: ${senderIsAdmin}`);
  console.log(`[${getTimestamp()}] Sender is whitelisted: ${WHITELIST.has(contactJid)}`);
  
  if (senderIsAdmin || WHITELIST.has(contactJid)) {
    console.log(`[${getTimestamp()}] â„¹ï¸ Skipping action - sender is admin or whitelisted`);
    return;
  }

  // Check if bot is admin - find bot by checking isMe property
  let botIsAdmin = false;
  for (const p of chat.participants) {
      try {
          const contact = await client.getContactById(getParticipantJid(p));
          if (contact.isMe && p.isAdmin) {
              botIsAdmin = true;
              break;
          }
      } catch (e) {
          // Continue checking
      }
  }
  
  if (!botIsAdmin) {
    console.log(`[${getTimestamp()}] âš ï¸ Bot is not admin - cannot take action on invite link`);
    return;
  }
  
  console.log(`[${getTimestamp()}] âœ… Bot is admin - proceeding with invite link moderation`); 

  await chat.sendSeen().catch(() => {});
  
  const target = author || contactJid;

// 1) Delete the invite message
try {
  console.log(`[${getTimestamp()}] Attempting to delete invite message...`);
  await msg.delete(true);
  console.log(`[${getTimestamp()}] ğŸ—‘ï¸ Invite message deleted successfully`);
} catch (e) {
  console.error(`[${getTimestamp()}] âŒ Failed to delete invite message:`, e.message);
  console.error(`[${getTimestamp()}] Error details:`, e);
}

// 2) Blacklist the sender AND the group codes (if not already)
try {
  const userJid = jidKey(contact);
  if (!(await isBlacklisted(userJid))) {
    await addToBlacklist(userJid);
    console.log(`âœ… User ${userJid} added to blacklist`);
  } else {
    console.log(`ğŸš« User ${userJid} is already blacklisted.`);
  }
  
  // Also blacklist each group code as potential LID
  for (const code of groupCodes) {
    const groupLid = `${code}@lid`;
    if (!(await isBlacklisted(groupLid))) {
      await addToBlacklist(groupLid);
      console.log(`âœ… Group LID ${groupLid} added to blacklist`);
    }
  }
} catch (err) {
  console.error(`[${getTimestamp()}] âŒ Failed to add to blacklist:`, err.message);
}

// 3) Remove (kick) the sender from group
try {
  await chat.removeParticipants([target]);
  console.log(`[${getTimestamp()}] âœ… Kicked user: ${target}`);
} catch (e) {
  console.error(`[${getTimestamp()}] âŒ Kick failed:`, e.message);
}

// 4) Build and send rich alert with group URL
const inviteCode = await chat.getInviteCode().catch(() => null);
const groupURL = inviteCode
  ? `https://chat.whatsapp.com/${inviteCode}`
  : '[URL unavailable]';

const alert = [
  'ğŸš¨ *WhatsApp Invite Detected & User Kicked*',
  `ğŸ‘¤ User: ${describeContact(contact)}`,
  `ğŸ“ Group: ${chat.name}`,
  `ğŸ”— Group URL: ${groupURL}`,
  'ğŸ”— Posted link(s):',
  ...matches.map(l => `   â€¢ ${l}`),
  'ğŸ—‘ï¸ Message Deleted: 1',
  'ğŸš« User was removed and blacklisted.',
  '',
  'ğŸ”„ *To unblacklist this user, copy the command below:*'
].filter(Boolean).join('\n');

await client.sendMessage(`${ALERT_PHONE}@c.us`, alert).catch(() => {});

// Send unblacklist command as separate message for easy copying
await client.sendMessage(`${ALERT_PHONE}@c.us`, `#unblacklist ${jidKey(contact)}`).catch(() => {});
console.log(`[${getTimestamp()}] âœ… Invite handled, message deleted & user kicked for ${describeContact(contact)}`);
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FOREIGN-JOIN RULE (Fixed for LID) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
client.on('group_join', async evt => {
  const pid = evt.id?.participant;
  if (!pid) return;

  const { isWhitelisted } = require('./services/whitelistService');
  const chat = await client.getChatById(evt.id.remote).catch(() => null);
  if (!chat?.isGroup) return;

  const contact = await client.getContactById(pid).catch(() => null);
  if (!contact) return;

  const userJid = jidKey(contact);

  if (await isBlacklisted(userJid)) {
    console.log(`ğŸš« User ${userJid} is blacklisted, attempting to remove...`);
    
    try {
      // Remove the blacklisted user
      await chat.removeParticipants([pid]);
      
      // Notify the kicked user
      const messageToUser = [
        'ğŸš« ×”×•×¡×¨×ª ××”×§×‘×•×¦×” ××›×™×•×•×Ÿ ×©××–×”×” ×”××©×ª××© ×©×œ×š ××•×¤×™×¢ ×‘×¨×©×™××” ×”×©×—×•×¨×”.',
        'â— ×× ××ª×” ×—×•×©×‘ ×©××“×•×‘×¨ ×‘×˜×¢×•×ª, × × ×œ×™×¦×•×¨ ×§×©×¨ ×¢× ×× ×”×œ ×”×§×‘×•×¦×”.',
        `ğŸ“± +${ADMIN_PHONE}`
      ].join('\n');
      await client.sendMessage(pid, messageToUser);
      
      // Get group URL for alert
      const inviteCode = await chat.getInviteCode().catch(() => null);
      const groupURL = inviteCode ? `https://chat.whatsapp.com/${inviteCode}` : '[URL unavailable]';
      
      // Alert the admin with enhanced info
      const alert = [
        'ğŸš¨ *Blacklisted User Auto-Kicked on Join*',
        `ğŸ‘¤ User: ${describeContact(contact)}`,
        `ğŸ“ Group: ${chat.name}`,
        `ğŸ”— Group URL: ${groupURL}`,
        `ğŸ•’ Time: ${getTimestamp()}`,
        'ğŸš« User was auto-removed (blacklisted).',
        '',
        'ğŸ”„ *To unblacklist this user, copy the command below:*'
      ].join('\n');
      await client.sendMessage(`${ALERT_PHONE}@c.us`, alert);
      
      // Send unblacklist command as separate message for easy copying
      await client.sendMessage(`${ALERT_PHONE}@c.us`, `#unblacklist ${userJid}`);
      console.log(`[${getTimestamp()}] âœ… Auto-kicked blacklisted user: ${userJid}`);
    } catch (err) {
      console.error(`âŒ Failed to auto-kick blacklisted user: ${err.message}`);
      // Alert admin about failure
      await client.sendMessage(`${ALERT_PHONE}@c.us`, 
        `âŒ Failed to auto-kick blacklisted user ${describeContact(contact)} from ${chat.name}: ${err.message}`);
    }
    return;
  }
});



/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ GLOBAL ERROR HANDLERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
process.on('unhandledRejection', async reason => {
  const txt = [
    'âŒ *Bot crashed with unhandledRejection*',
    `â€¢ When: ${new Date().toLocaleString('en-GB',{timeZone:'Asia/Jerusalem'})}`,
    `â€¢ Reason: ${reason}`
  ].join('\n');
  console.error(txt);
  client.sendMessage(`${ALERT_PHONE}@c.us`, txt).catch(() => {});
});

process.on('uncaughtException', async err => {
  const txt = [
    'âŒ *Bot crashed with uncaughtException*',
    `â€¢ When: ${new Date().toLocaleString('en-GB',{timeZone:'Asia/Jerusalem'})}`,
    `â€¢ Error: ${err.message}`
  ].join('\n');
  console.error(txt);
  client.sendMessage(`${ALERT_PHONE}@c.us`, txt).catch(() => {});
});

client.on('disconnected', async reason => {
  const txt = [
    'âŒ *WhatsApp client disconnected*',
    `â€¢ When: ${new Date().toLocaleString('en-GB',{timeZone:'Asia/Jerusalem'})}`,
    `â€¢ Reason: ${reason}`
  ].join('\n');
  console.warn(txt);
  client.sendMessage(`${ALERT_PHONE}@c.us`, txt).catch(() => {});
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DEBUG HOOKS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
client.on('loading_screen', pct => console.log(`ğŸ”„ Loading screen: ${pct}%`));
client.on('change_state', st => console.log('ğŸ§­ State changed to:', st));

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ START BOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
console.log(`[${getTimestamp()}] ğŸ“¡ Calling client.initialize()â€¦`);
client.initialize();